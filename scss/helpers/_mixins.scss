$breakpoints: (
	'xs': ( min-width:  500px ),
	'sm': ( min-width:  768px ),
	'md': ( min-width:  992px ),
	'lg': ( min-width: 1200px )
);

@mixin bp($name) {
	@if map-has-key($breakpoints, $name) { // 1
		@media #{inspect(map-get($breakpoints, $name))} { // 2
			@content;
		}
	}
	@else { // 3
		@warn "Couldn't find a breakpoint named `#{$name}`."; // 4
	}
}

/**/
$xs: ( max:  767px );
$sm: ( min:  768px );
$md: ( min:  992px );
$lg: ( min: 1200px );
$sm-only: ( min: map-get($sm, min), max: map-get($md, min) - 1 );
$md-only: ( min: map-get($md, min), max: map-get($lg, min) - 1 );
$point : null;
@mixin breakpoint($point) {
  $query: "";
  @if map-has-key($point, min) { 
  	$query: append($query, "(min-width: #{map-get($point, min)})") 
  }
  @if map-has-key($point, min) and map-has-key($point, max) { 
  	$query: append($query, "and") 
  }
  @if map-has-key($point, max) { 
  	$query: append($query, "(max-width: #{map-get($point, max)})") 
  }
  @media screen and #{$query} { @content; }
}
/**/

@mixin mq($point, $IE9: false, $query1: min, $query2: width) {
	@if $IE9 == true{
		.lt-ie9 & {
			@content;
		}
	}

	@media (#{$query1}-#{$query2}: $point) {
		@content;
	}
}


@function palette($palette, $tone: 'base') {
	@return map-get(map-get($palettes, $palette), $tone);
}


@function first($list) {
  @return nth($list, 1);
}

@function last($list) {
  @return nth($list, length($list));
}

@mixin rempx($elprop: 'padding-left', $sizes...) {

	$pxs: ();
	$rem: ();
	@if length($sizes) > 1 { 
		@each $size in $sizes {
			@if $size != auto and unit($size) != '%' {
				$pxs: append( $pxs, $size * 10px );
				$rem: append( $rem, $size * 1rem );
			} @else {
				$pxs: append( $pxs, $size );
				$rem: append( $rem, $size );
			}
		}
		#{$elprop}: $pxs;
		#{$elprop}: $rem;
	} @else {
		#{$elprop}: first($sizes) * 10px;
		#{$elprop}: first($sizes) * 1rem;
	}

}

@mixin fs($sizeValue: 1.6) {
	@include rempx(font-size,$sizeValue);
}


@mixin center-align($dir: false) {
	$map: (
		top:  ( Y ),
		left: ( X )
	);

	@if map_get($map, $dir) != null {
		#{$dir}: 50%;
		transform: #{"translate#{map_get($map,$dir)}(-50%)"};
	} @else {
		transform: translate(-50%,-50%);
		top: 50%;
		left: 50%;
	}
}


@mixin box($size: 2) {
	@include rempx(width, $size);
	@include rempx(height, $size);
}



// http://jennifermann.ghost.io/setting-fixed-table-widths-using-sass/
@mixin th-width($col, $width) {
	#{$col} {  
		width: $width;  
	}
}

@mixin table-columns($widths) {
	table-layout: fixed;
	width: 100%;

	th, td {
		overflow: hidden; 
		text-overflow: ellipsis; 
		white-space: nowrap;
	}

	$n: 1;
	$var: "th:nth-child(" + $n + ")";
	@each $width in $widths {
		@include th-width($var, $width);
		$n: $n + 1;
		$var: "th:nth-child(" + $n + ")";
	}
}

@mixin el-width($col, $width) {
	#{$col} {
		$width: $width;
	}
}

@mixin list-columns($widths...) {
	width: 100%;

	li {
		overflow: auto;  
		border-bottom: 1px solid #eeeeee;  
		display: block;
		& > div {
			float: left;
			& > div {
				padding: 6px 12px;
				overflow: hidden; 
				text-overflow: ellipsis; 
				white-space: nowrap;
			}
		}
	}

	$n: 1;
	$var: "li>div:nth-child(" + $n + ")";
	@each $width in $widths {
		@include el-width($var, $width);
		$n: $n + 1;
		$var: "li>div:nth-child(" + $n + ")";
	}
}

@mixin row-table {
  display: table !important;
  width: 100%;

  [class*="col-"]{
    float:none!important;
    display: table-cell!important;
    vertical-align: middle;
    &.td-top{ vertical-align: top!important; }
    &.td-bottom { vertical-align: bottom!important; }
  }  
}
.row-table.row-table-xs {
  @include row-table;
}

@media (min-width: 768px) {
  .row-table {
    @include row-table;
  }
}



@mixin debug-map($map) {
  @at-root {
    @debug-map {
      __toString__: inspect($map);
      __length__: length($map);
      __depth__: depth($map);
      __keys__: map-keys($map);
      __properties__ {
        @each $key, $value in $map {
          #{'(' + type-of($value) + ') ' + $key}: inspect($value);
        }
      }
    }
  }
}